# Module Testing Experiment

I thought this week I would check out the new experiment from Terraform 0.15 around module testing. I feel like I should highlight the fact this is *experimental*, as in "don't use in production" and also known as "probably broken and subject to change at any time". In fact, you can't even find the docs page by navigating the Terraform website. You have to follow a link from the CHANGELOG for Terraform 0.15. 

The [page is here](https://www.terraform.io/docs/language/modules/testing-experiment.html) BTW.

Go ahead and read that doc, I'm not going to rehash the whole thing here. Instead I'll try to distill down how this feature works.

## Folder layout

In the module where you want to add testing, you will create a subfolder called `tests`, and in that subfolder you with create subfolders for each testing round you want to do. When you run `terraform test` from the root module, it will look for the `tests` folder and run the tests it finds in any subfolders. I imagine eventually you'll be able to select which tests to run, but right now functionality is extremely limited.

## Test provider

The tests use a builtin provider creatively called `test`. Don't bother looking for any docs on the Terraform registry about what resources and data sources are part of the `test` provider, **there are no docs**.

There is only one resource in the provider and its called `test_assertions`. The `test_assertions` resource runs one or more tests, which must return true for the assertion to pass. You can have more than one `test_assertion` resource in a test configuration file. We'll get into what those tests look like in a moment.

## Terraform test command

When you run `terraform test` from the root module, Terraform will create the resources defined in your module and then run the tests it finds in the `tests` folder against the generated resources. Once the tests complete (pass or fail), Terraform will destroy the resources it created.

The `terraform test` command does not allow you to pass variables at the command line or through a file. That's because it is creating the resources through a module defined in the testing directory. I realize that sounds confusing, and I will explain it shortly. It will use whatever the defaults are for variables, and the providers respect the use of environment variables, but you can't create a bunch of `.tfvars` files and pass them to `terraform test`.

## Test provider resource

Okay, let's get back to the `test_assertions` resource. Let's do a run-down of the attributes in the resource:

* `component` - This is a `string` defining what component is being tested in the assertion. You can call this whatever you want.
* `equal` - This is a named nested block that will contain a test with an attribute to check and the expected value of that attribute.
* `check` - This is a named nested block that will contain a test with an expression that will evaluate to `true` or `false`.

`equal` block attributes:

* `description` - An optional (but strongly recommended) human-readable description of what's being tested by this assertion.
* `got` - The actual result value generated by the relevant component.
* `want` - The value that the component is expected to have generated.

`check` block attributes:

* `description` - An optional (but strongly recommended) human-readable description of what's being tested by this assertion.
* `condition` - An expression that must be true in order for the test to pass. Must evaluate to `true` or `false`.

Basically you have two type of tests you can run, and they aren't very different. Instead of using an `equal` block, you could simply use a logical operator to compare the `got` and `want` values in a `check` block. But I think it's cleaner to use an `equal` block when you can.

## Root module reference

The values you are testing come from the root module by doing some inception level stuff. In the test configuration file, you will create a module object that references the root module like this:

```terraform
module "main" {
    source = "../.."
}
```

When `terraform test` runs, it is running in the context of the test configuration and pulling in the root module. If you want to set specific variable values, you can do it here. At the moment, the variables have to be hardcoded in the test config. The `terraform test` command doesn't appear to evaluate variables defined in a `terraform.tfvars` file in the testing folder or variables defined using the `TF_VAR_variable_name` environment variable method.

## Demo

I've created two demos. One is basically the same as what is on the docs page, and I put it in the `basic_test` folder. The second creates a container group on Azure Container Instance running the Pet Store swagger API image on port 8080. This way we can test that not only does the container start up, but also check to make sure it is serving content. That seems.. useful. I put that demo in the `web_app_test` folder. Originally I was going to use App Service, but I ran into some annoying issues with GitHub integration and eventually said, *"Screw it"*.

To run each demo, simply go into the folder and run `terraform init` followed by `terraform test`. The `web_app_test` uses the Terraform Cloud backed, so you'll need to create a workspace on Terraform Cloud to initialize. Interestingly, you don't need to set any environment variables for Azure, because the `terraform test` command runs locally and not on the Terraform Cloud backend. That's *suboptimal*. You will need to be logged into Azure via the CLI and select the subscription where you want the resources deployed.